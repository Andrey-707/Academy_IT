# В Python для работы с регулярными выражениями используется модуль re.

# Основные функции модуля re:

# match - ищет последовательность в начале строки
# search - ищет первое совпадение с шаблоном
# findall - ищет все совпадения с шаблоном. Возвращает результирующие строки в виде списка
# finditer - ищет все совпадения с шаблоном. Возвращает итератор
# compile - компилирует регулярное выражение. К этому объекту затем можно применять все перечисленные функции
# fullmatch - вся строка должна соответствовать описанному регулярному выражению

# Кроме функций для поиска совпадений, в модуле есть такие функции:

# re.sub - для замены в строках
# re.split - для разделения строки на части

import re

from rich import print

s = """Через какие трудности приходится проходить Санта Клаусу каждый год, чтобы под каждой елкой появился тот самый подарок, 
расскажет мульт «Нико 2».   Маленький олененок Нико мечтает продолжить дело отца. Ведь его папа самый знаменитый и 
у7важаемый bob@y_mail.ryeueru ол8ень на свете. О его работе мечтает каждый – он трудится в упряжке самого Санта Клауса. Но сам Нико пока 
еще слишком 23маленький для «такого» тяжелого и ответственного дела. Так что пока он сам ждет Санту с подарками. Накануне 
Рождества tom_3456@gma9il.com он «встречается со своими» самыми близкими друзьями: белкой Джулиусом, лаской Вилмой и сводным братишкой 
Джонни, 7чтобы вместе встречать Рождество и не пропустить заветную оленью упряжку. Но, как всегда в пути Санту ждут 
невероятные kira-3456@gmail.com приключения. На этот раз все настолько серьезно, что детишки всего мира могут и вовсе остаться без 
подарков. kfu@stud.kpfu.ru «Хорошо, что Нико и его товарищи» всегда готовы прийти на помощь. Им не страшны любые испытания и приключения: 
ведь lili@mail.ru среди них – достойный сын одного из оленей упряжки самого Санта Клауса.  Советуем смотреть онлайн «Нико 2», 
добрый и милый рождественский мультик, который отлично подойдет для семеного просмотра"""

# Далее символ "r" используется как r-срока

# Разбить текст на буквы, очистить от знаков препинания (выводит каждую букву и цифры отдельно, так же
# знак "_" подчеркивания остается).
s_reg = r"\w" # \w - ищем ВСЕ буквы (отдельно)
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Разбить текст на слова, очистить от знаков препинания (выводит каждое слово и цифры отдельно, так же
# знак "_" подчеркивания остается).
s_reg = r"\w+" # \w+ - ищем ВСЕ слова (отдельно)
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Вывести первое слово текста.
s_reg = r"^\w+" # ^\w+ - ищем одно слово (первое)
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Вывести последнее слово текста.
s_reg = r"\w+$" # \w+$ - ищем одно слово (последнее)
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Вывести текст, склеив его по две буквы. Если для следующей буквы нет пары, она удалится (знаки
# препинания УДАЛЯЮТСЯ).
s_reg = r"\w\w"
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Вывести первые две буквы каждого слова (знаки препинания УДАЛЯЮТСЯ).
s_reg = r"\b\w\w" # \b - начинается С \w\w - две буквы
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Вывести первые три буквы каждого слова (знаки препинания УДАЛЯЮТСЯ).
s_reg = r"\b\w\w\w" # \b - начинается С; \w\w - три буквы
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Вывести ВСЕ слова, состоящие РОВНО из трех букв (знаки препинания УДАЛЯЮТСЯ).
s_reg = r"\b\w\w\w\b" # \b - начинается С; \w\w\w - три буквы; \b заканчивается НА
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Вывести ВСЕ слова, состоящие РОВНО из пяти букв (знаки препинания УДАЛЯЮТСЯ).
s_reg = r"\b\w{5}\b" # {5} - последовательность букв
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Вывести ВСЕ слова, состоящие ОТ двух ДО четырех букв (знаки препинания УДАЛЯЮТСЯ).
s_reg = r"\b\w{2,4}\b" # {2,4} - две, три или четыре подходит под условие
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Вывести ВСЕ слова, состоящие ОТ двух ДО бесконечности букв (знаки препинания УДАЛЯЮТСЯ).
s_reg = r"\b\w{2,}\b" # {2,} - две и до бесконечности подходит под условие
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# Вывести все самые большие слова (10 букв и более, знаки препинания УДАЛЯЮТСЯ)
s_reg = r"\b\w{10,}\b"
c_reg = re.compile(s_reg)
# print(*c_reg.findall(s))

# !!! ДАЛЕЕ КОМПИЛЛЯЦИЮ re.compile ИСПОЛЬЗУЕМ ВНУТРИ РЕГУЛЯРНОГО ВЫРАЖЕНИЯ!!!

# Вывести ВСЕ цифры, встречающиеся в тексте отдельно (разбить длинные числа на отдельные цифры).
# print(re.findall(r"\d", s))

# Вывести ВСЕ числа, встречающиеся в тексте (длинные числа НЕ разбиваются на отдельные цифры).
# print(re.findall(r"\d+", s))

# Вывести ВСЁ, что начинается с цифы, заканчивается текстом (даже если это находится в СЕРЕДИНЕ слова).
# print(re.findall(r"\d\w+", s))

# Вывести ВСЕ слова, которые начинаются с цифы, заканчивается текстом (если находится в СЕРЕДИНЕ слова,
# то не выводится).
# print(re.findall(r"\b\d\w+", s))

# Вывести ВСЕ слова, в которых есть опечатка в виде числа (число находится внутри слова).
# print(re.findall(r"[а-я]{1,2}\d\w+", s))

# Вывести ВСЕ слова, которые начинаются с буквы "н", "м" или "т"
# print(re.findall(r"\b[нмт]\w+", s))

# Вывести ВСЕ слова, которые НЕ начинаются с буквы "т", "п", "к", "г" или с символа "пробел"
# print(re.findall(r"\b[^тпкг ]\w+", s))

# Вывести ВСЕ слова, которые начинаются с "тр"
# print(re.findall(r"тр\w+", s))

# Вывести ВСЕ словосочетания, которые начинаются с трех букв (или символов) ВНУТРИ которых встречается
# "тр" затем может быть 7 букв.
# print(re.findall(r".{3}тр.{7}", s)) # .{3} - любой символ три раза

# Вывести ВСЕ слова, внутри которых находится "тр". До и ПОСЛЕ "тр"  может быть любое количество букв.
# print(re.findall(r"\w{,}тр\w{,}", s))

# Вывести ВСЕ слова (именно слова), которые находятся в кавычках. Пример: «слово»
# print(re.findall(r"«\w+»", s))

# Вывести ВСЕ слова, образца <<кавычки_текст_пробел_текст_кавычки>>
# print(re.findall(r"«\w+\s\w+»", s))

# Вывести ВСЕ слова И словосочетания, которые находятся внутри кавычек.  Пример: «Хорошо, что Нико и его товарищи»
# print(re.findall(r"«.{,}»", s)) # так
# print(re.findall(r"«.+»", s)) # или так

# Вывести одно ИЛИ два ИЛИ три слова внутри кавычек.
# print(re.findall(r'«\w+»|«\w+\s\w+»|«\w+\s\w+\s\w+»', s)) # символ "|" - это логическое или

# Найти ВСЕ почты, которые встречаются в тексте (ВКЛЮЧАЕТ ОШИБОЧНЫЕ, например БЕЗ .ru или .com)
# print(re.findall(r"\w+@\w+", s))

# Найти ВСЕ почты, которые встречаются в тексте (ВКЛЮЧАЕТ ОШИБОЧНЫЕ, например оканчивающиется НА .ryeueru или .kpfu)
# print(re.findall(r"\w+@\w+\.\w+", s))

# Найти ВСЕ почты (достаточно правильная выборка).
# print(re.findall(r"[\w-]+@[a-zA-Z.]+\.[a-zA-Z]{2,4}", s)) # [\w-] означает символ дефиса "-"

# ###########################################################################################################

s2 = "aa aba abba abbba abca abea"  # -> aa aba abba abbba"

# Вывести словосочетания образца << буква "а", буква "b" сколько угодно раз, буква "а" >>
# print(re.findall(r"ab*a", s2)) # b* - означает, что букв "b" может быть от нуля до бесконечности

# Условие, аналогичное предыдущему
# print(re.findall(r"ab{,}a", s2))

# Условие, похоже на предыдие два, НО есди букв "b" нет в слове, то не выводится
# print(re.findall(r"ab+a", s2))

# Найти в тексте слова с буквой "b" между двумя "a" или просто две буквы "а"
# print(re.findall(r"ab?a", s2)) # символ "?" означает строго одно повторение символа в нексте или его отсутствие (буквы "b")

# Найти в тексте строго "aa" или "aba"
# print(re.findall(r"aa|aba", s2))

# Найти в тексте слова с буквой "b" между двумя "a". Букв "b" может быть одна или бесконечность
# print(re.findall(r"ab{1,}a", s2))

# ###########################################################################################################

s3 = "23 2+3 2++3 2+++3 345 5667"  # -> 23 2+3 2++3 2+++3

# Найти число "2", сколько угодно символов "+", число "3"
# print(re.findall(r"2\+*3", s3))

s4 = "23 2+3 2++3 2+++3 345 5667 6+7 569+23"  # -> 23 2+3 6+7 569+23"

# Найти <<23>> (может быть отдельно или внутри числа) или <<2+3>>
# print(re.findall(r"2\+?3", s4))

# Найти число или <<чисо плюс число>>
# print(re.findall(r"\d+\+?\d+", s4))

# ##########################################################################################################################

tweet = '''Good advice! RT @TheRbsjTH: What I would...
https://t.co/dwjjkwkwef  cc: @AnnTrehcsl #netwar'''

# Замена символа ("G" заменить на "T")
# print(re.sub("G", "T", tweet))

# Удалить URL из текста
# print(re.sub(r'http\S*\s*', '', tweet)))

# Удалить обращение к пользователю (то, что начинается с символа "@"")
# print(re.sub(r"@\S*\s*", "", tweet))

# Удалить из текста <<RT>> и <<cc:>>
# print(re.sub(r"RT\s*|cc:\s*", "", tweet))

# Удалить из текста символ решетки "#" и символы, которые идут за ним, удаляем #netwar
# print(re.sub(r"#\S*\s*", "", tweet))

# Удалить из текста знаки препинания и символ перевода строки [!?,.:\n]
# print(re.sub(r"[!?,.:\n]", "", tweet))
