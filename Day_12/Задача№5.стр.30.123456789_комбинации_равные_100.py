# Задача№5.стр.30. 123456789 комбинации равные 100
# У вас есть девять цифр 1,2, ..., 9. Именно в таком порядке вы можете вставлять между ними "+", "-" или ничего.
# У вас будут получаться выражения вида 123+45-6+7-89.
# Найдите все из них, которые равны 100.

from rich import print 


# Решение_1. С использованием посторонних модулей 'operator' и 'itertools'.
from operator import add, sub
from itertools import product


# дана стока чисел от 1 до 9
nums = "1 2 3 4 5 6 7 8 9"

# из строки сделаем список чисел (int)
list_of_nums = [int(i) for i in nums.split(" ")]

# входные данные
print("Входные данные:")
print(*list_of_nums)


def equal_to(L:list):
    '''Функция принимает список чисел и выдает возможные варианты решений по средствам функций print()'''
    global k, count
    k = 0 # переменная-счетчик вызовов функции product()
    count = 0 # переменная-счетчик возможных вариантов решения задачи
    for x in product(range(3), repeat=8): # вызовов функции product() будет 3**8
        s = 0
        op = add
        num = L[0]
        for i, a in enumerate(x):
            if a == 0:
                num = num*10 + L[i+1]
            if a == 1:
                s = op(s, num)
                op = add
                num = L[i+1]
            if a == 2:
                s = op(s, num)
                op = sub
                num = L[i+1]
        s = op(s, num)
        if s == 100:
            print(L[0], end="")
            for i, kod in enumerate(x, 1):
                if kod == 1:
                    print(" + ", end="")
                if kod == 2:
                    print(" – ", end="")
                print(L[i], end="")
            print(" = 100")
            count += 1
        k += 1


# выходные данные
print("\nВозможные комбинации для числа 100:")
# вызываем функцию и передаем в нее список чисел (int)
equal_to(list_of_nums)

# поскольку знаков, которые можно поставить между цифрами три ("+", "-" и " ") и мест, куда их можно поставить -
# восемь, то вызовов функции product() будет 3**8, т.е. функция сделает 6561 итераций.
print("\nКол-во итераций:", k)

# когда выполняется условие (в сумме получаем цифру 100), срабатывает переменная счетчик
print("Кол-во решений:", count)

print() # пустая строка

# --------------------------------ДОПОЛНЕНИЕ------------------------------------------------------------------------
"""
itertools здесь нужен только для for x in product(range(3), repeat=8):
Оно генерирует всевозможные комбинации чисел 0-2 в кортеже с 8-мью позициями

Вообще, вместо такой генерации можно просто использовать троичную систему счисления. И каждая строка будет новым
числом из троичной системы счисления, преобразованная к tuple
То есть делаете range по десятичной системе, а потом число в переменную преобразуете в троичную. И добавляете нолики
слева, если необходимо

из operator взяли только op = sub и op = add. Вместо этого можно было создать флаг op = "+"/op = "-". И вместо
s = op(s, num) написать if op = "+": s += num  или if op = "-": s -= num

0   в троич = 0  в десятич
1   в троич = 1  в десятич
2   в троич = 2  в десятич
10  в троич = 3  в десятич
11  в троич = 4  в десятич
12  в троич = 5  в десятич
20  в троич = 6  в десятич
21  в троич = 7  в десятич
22  в троич = 8  в десятич
100 в троич = 9  в десятич
101 в троич = 10 в десятич

Получается генерация таких же кортежей, как у product из библиотеки itertools
(0, 0, 0, 0, 0, 0, 0, 0) = 0
(0, 0, 0, 0, 0, 0, 0, 1) = 1
(0, 0, 0, 0, 0, 0, 0, 2) = 2
(0, 0, 0, 0, 0, 0, 1, 0) = 3
(0, 0, 0, 0, 0, 0, 1, 1) = 4
(0, 0, 0, 0, 0, 0, 1, 2) = 5 
(0, 0, 0, 0, 0, 0, 2, 0) = 6
(0, 0, 0, 0, 0, 0, 2, 1) = 7
(0, 0, 0, 0, 0, 0, 2, 2) = 8
(0, 0, 0, 0, 0, 1, 0, 0) = 9
(0, 0, 0, 0, 0, 1, 0, 1) = 10
"""

#####################################################################################################################

# Решение_2. Без использования посторонних модулей 'operator' и 'itertools'

# словарь для приведения к 16 ричной системе счисления
hex_dic = {0: "0", 1: "1", 2: "2", 3: "3",
           4: "4", 5: "5", 6: "6", 7: "7",
           8: "8", 9: "9",10: "a", 11: "b",
           12: "c", 13: "d", 14: "e", 15: "f", 16: "j"}

def convert(n1, n2, s):
    '''Функция конвертирует число 's' из 'n1' в 'n2' системы счисления'''
    s10 = int(s, n1)
    if n2 == 10:
        return s10
    l = [s10]
    i = 0
    while l[i] > (n2-1):
        a = l[i] % n2
        b = (l[i] - a) // n2
        l.append(b)
        l[i] = a
        i += 1
    s2 = ""
    for j in range(len(l)-1, 0-1, -1):
        s2 += hex_dic[l[j]]
    return s2

# словарь возможных символов, добавляемых между числами
sym_dic = {'0': "", '1': " - ", '2': " + "}



# дана стока чисел от 1 до 9
nums = "1 2 3 4 5 6 7 8 9"

# из строки сделаем список чисел (int)
list_of_nums = [int(i) for i in nums.split(" ")]

# входные данные
print("Входные данные:")
print(*list_of_nums)

def equal_to(L:list):
    '''Функция принимает список чисел и выдает возможные варианты решений по средствам функций print()'''
    global k, count
    k = 0 # переменная-счетчик числа итераций
    count = 0 # переменная-счетчик возможных вариантов решения задачи
    for i in range(3 ** 8):
        k += 1
        i_3 = convert(10, 3, str(i))
        l_symbol = ['0'] * (8 - len(i_3)) + list(i_3)
        combin = 0
        pr_oper = "+"
        num = L[0]

        for i_sym, sym in enumerate(l_symbol):
            if sym == '0':
                num = int(str(num) + str(L[i_sym + 1]))
            elif sym == '1':
                if pr_oper == "+":
                    combin += num
                elif pr_oper == "-":
                    combin -= num
                pr_oper = "-"
                num = L[i_sym + 1]
            elif sym == '2':
                if pr_oper == "+":
                    combin += num
                elif pr_oper == "-":
                    combin -= num
                pr_oper = "+"
                num = L[i_sym + 1]
        if pr_oper == "+":
            combin += num
        elif pr_oper == "-":
            combin -= num

        if combin == 100:
            print(f"1{sym_dic[l_symbol[0]]}2{sym_dic[l_symbol[1]]}3{sym_dic[l_symbol[2]]}"
                  f"4{sym_dic[l_symbol[3]]}5{sym_dic[l_symbol[4]]}6{sym_dic[l_symbol[5]]}"
                  f"7{sym_dic[l_symbol[6]]}8{sym_dic[l_symbol[7]]}9 = {combin}")
            count += 1

# выходные данные
print("\nВозможные комбинации для числа 100:")
# вызываем функцию и передаем в нее список чисел (int)
equal_to(list_of_nums)

print("\nКол-во итераций:", k)
# когда выполняется условие (в сумме получаем цифру 100), срабатывает переменная счетчик
print("Кол-во решений:", count)
