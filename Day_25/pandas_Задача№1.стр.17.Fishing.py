# Задача№1.стр.17.Fishing.

# Файл Fishing.csv содержит результаты опроса о рыбалке: респонденты, заполняя опросник, подробно описывали
# свою недавнюю рыбалку.

# Описание переменных в DataFrame:

# * mode: выбранный тип рыбалки: на берегу (beach), на пирсе (pier), на своей лодке (boat) и арендованной
# лодке (charter);
# * price: стоимость выбранного типа рыбалки;
# * catch: коэффициент улова при выбранном типе рыбалки;
# * pbeach: стоимость рыбалки на берегу;
# * ppier: стоимость рыбалки на пирсе;
# * pboat: стоимость рыбалки на своей лодке;
# * pcharter: стоимость рыбалки на арендоанной лодке;
# * pbeach: коэффициент улова рыбалке на берегу;
# * ppier: коэффициент улова рыбалке на пирсе;
# * pboat: коэффициент улова рыбалке на своей лодке;
# * pcharter: коэффициент улова рыбалке на арендоанной лодке;
# * income: доход в месяц

# Задача:

# 1) Загрузить таблицу из файла Fishing.csv и сохранить её в DataFrame 'dat'. Вывести на экран первые 8
# строк загруженного DataFrame.
# 2) Добавить, используя метод .apply(), столбец log_income, содержащий натуральный логарифм доходов
# респондентов.
# 3) Посчитать для каждого респондента абсолютное значение отклонения price от pbeach и сохранить результаты
# в столбец pdiff
# Подсказка 1: Для нахождения абсолютного значения числа используется функция abs()
#   Пример: резултьтатом abs(-8) будет 8
# Подсказка 2: пример с lambda функцией в первом уроке этого модуля.
# 4) Сгруппировать наблюдения в таблице по признаку тип рыбалки (mode) и вывести для каждого типа свою цену
# (price), которую респонденты заплатили за рыбалку.
# 5) Сгруппировать наблюдения в таблице по признаку тип рыбалки (mode) и вывести для каждого типа разницу
# между медианным (median) и средним значением (mean) цены (price), которую респонденты заплатили за рыбалку.
# Подсказка: можно написать свою lambda функцию для подсчета разницы между медианой и средним значением и
# применить её внутри метода дря агрегирования. Внимание: название самостоятельно написанной функции будет
# выводиться уже без кавычек.
# 6) Сгруппировать наблюдения в таблице по признаку тип рыбалки (mode) и сохранить полученные DataFrames
# (один для каждого типа рыбалки) в отдельные .csv файлы. В итоге должно получиться четыре разных .csv файла.
# Подсказка: можно запустить следующий код и посмотреть что получится:

# for name, data in dat.groupby("mode"):
#   print(name, data)

# 7) Отсортировать строки в DataFrame в соответсвтии со значениями income в порядке убывания таким образом,
# чтобы результаты сортировки сохранялись в исходном DataFrame.
# 8) Отсортировать строки в DataFrame в соответсвтии со значениями price и income в порядке возрастания.
# Можно ли сказать, что люди с более низким доходом и выбравшие более дешевый тип рыбалки, в целом,
# предпочитают один тип рыбалки, а люди с более высоким доходом и более дорогой рыбалкой - другой? Ответ
# записать в виде тектовой ячейки или в виде комментария.
# 9) Любым известным способом проверить, есть ли в DataFrame пропущенные значения. Если есть, удалить строки
# с пропущенными значениями. Если нет, написать комментарий, что таких нет.

import pandas as pd
import numpy as np

from rich import print


# Решение:

'''1'''
# В pandas передаем Fishing.csv, сохраняем в DataFrame 'dat'. Методом .head(8) выведены на экран первые
# 8 строк.
# Из-за странностей таблицы, колонке 'index' присвоено значение 0 (колонка удаляется). По умолчанию колонок
# 14, стало 13 .
dat = pd.read_csv('Fishing.csv', index_col=0)
# print(dat.head(8))

'''2'''
# При помощи библиотеки numpy к столбцу 'income' применено взятие логорифма
# dat['log_income'] = np.log(dat['income'])
# print(dat['log_income'].head(8))
# print(dat.head(8))
# Ещё столбец можно добавить, используя метод .apply(). Добавляем столбец log_income, содержащий натуральный
# логарифм доходов респондентов.
# dat['log_income'] = dat['income'].apply(np.log)
# print(dat.head(8))

'''3'''
# Абсолютное значение отклонения price от pbeach для каждого респондента. Результат сохранен в столбец pdiff
# Для удобства визуализации методом .head(8) выведены на экран первые 8 строк (нет в условии задачи).
# dat['pdiff'] = abs(dat['price'] - dat['pbeach'])
# print(dat.head(8)) # вывод таблицы, в которую добавилась колонка 'pdiff'
# print(dat['pdiff'].head(8)) # вывод отдельно колонки (Series) 'pdiff'

'''4'''
# DataFrame 'dat' сгруппирована по признаку тип рыбалки (mode). Для каждого типа рыбалки (mode) выводится
# своя цена (price).
# сгруппировано по 'mode', вывод в виде списка для первых 8 строк DataFrame
# print(list(dat.head(8).groupby('mode')))

# Решение 4 пункта с выводом среднего значения 'price' для каждого 'mode':
# print(dat.groupby('mode').agg(['mean'])['price'])

# либо так (результат одинаковый). Переменную 'dat_group' используем дальше в пункте 5
dat_group = dat.groupby('mode')['price']
# print(dat_group.agg(['mean']))

'''5'''
# Лямбда функция для подсчета разницы между медианой и средним значением.
f1 = lambda x: np.median(x) - np.mean(x)
# DataFrame 'dat' сгруппирована по признаку тип рыбалки (mode) (это условие выполнена в пункте 4, берем
# от туда 'dat_group'). Для каждого типа рыбалки (mode) выводится разница между медианным (функция numpy
# .median()) и средним (функция numpy .mean()) значениями цены (price).
# print(dat_group.agg([f1]))

'''6'''
# Код из подсказки к заданию:
# for name, data in dat.groupby("mode"):
#   print(name, data)

# DataFrame 'dat' сгруппирована по признаку тип рыбалки (mode). Полученные DataFrames (один для каждого типа
# рыбалки) сохраняются .to_csv() в отдельные .csv файлы (name). В итоге должно получиться четыре разных .csv
# файла.
# for i, df in dat.groupby('mode'):
    # print(i)
    # print(df)
    # name = i+'.csv'
    # df.to_csv(name) # создание CSV файла для каждого 'mode' рыбалки

'''7'''
# Строки в DataFrame отсортированы в соответсвтии со значениями income в порядке убывания. Результаты
# сортировки сохраняются в исходном DataFrame.
# ascending=False - сортировка по УБЫВАНИЮ
# если не указать inplace=True, то переименовать не получится
# dat.sort_values(['income', 'Unnamed: 0'], ascending=False, inplace=True)
# print(dat)

'''8'''
# Строки в DataFrame отсортированы в соответсвтии со значениями 'price' в порядке возрастания.
# Ответ записать в виде тектовой ячейки или в виде комментария.
dat_p = dat.sort_values(['price'])
# print("DataFrame sorted by 'price'")

# для анализа выведем по 10 значений с начала и с конца таблицы
# print(dat_p.head(10)) # 10 строк с начала
# print("ВЫВОД по первым 10 строкам DataFrame: Типы рыбалок pier.\n")
# print(dat_p.tail(10)) # 10 строк с хвоста
# print("ВЫВОД по последним 10 строкам DataFrame: Типы рыбалок charter.\n")

# сохраним данные в CSV файл
# dat_p.to_csv('dat_p.csv')

# Ответ записать в виде тектовой ячейки или в виде комментария.
# print("Ответ: Типы рыбалок pier.\n")

# Строки в DataFrame отсортированы в соответсвтии со значениями income в порядке возрастания.
# Ответ записать в виде тектовой ячейки или в виде комментария.
dat_i = dat.sort_values(['income'])
# print("DataFrame sorted by 'income'")

# для анализа выведем по 10 значений с начала и с конца таблицы
# print(dat_p.head(10)) # 100 строк с начала
# print("ВЫВОД по первым 10 строкам DataFrame: Типы рыбалок pier.\n")
# print(dat_p.tail(10)) # 100 строк с хвоста
# print("ВЫВОД по последним 10 строкам DataFrame: Типы рыбалок charter.\n")

# сохраним данные в CSV файл
# dat_i.to_csv('dat_i.csv')

# Ответ записать в виде тектовой ячейки или в виде комментария.
# print("Ответ: Типы рыбалок charter.\n")

'''9'''
# Проверим, есть ли в DataFrame пропущенные значения. Если есть, удалим строки с пропущенными значениями.
# Если нет, напишем комментарий, что таких нет.
print(dat.info()) # информация по DataFrame
print(dat.isnull().agg('sum')) # вывести нулевые значения (в результате их 0)
print("Нет пропущенных данных") # 1182 non-null, то есть все ячейки не пустые
