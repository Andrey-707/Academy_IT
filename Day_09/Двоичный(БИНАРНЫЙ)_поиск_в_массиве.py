# ДВОИЧНЫЙ (БИНАРНЫЙ) ПОИСК

# !!! Двоичный (бинарный) поиск работает ТОЛЬКО ЕСЛИ МАССИВ ОТСОРТИРОВАН !!!

# Поиск имени 'key' в списке 'contacts'
contacts = ["Авдотья", "Агафья", "Аида", "Аким", "Аксинья", "Алевтина", "Александр", "Александра", "Алексей", "Алёна",
     "Алина", "Алла", "Анастасия", "Анатолий", "Ангелина", "Андрей", "Анисья", "Анна", "Антон", "Антонина", "Анфим",
     "Анфиса", "Аполлинария", "Арина", "Ария", "Аркадий", "Арсений", "Артём", "Артемий", "Ася", "Аэлита", "Богдан",
     "Богдана", "Борис", "Борислав", "Вадим", "Валентин", "Валентина", "Валерий", "Валерия", "Варвара", "Василий",
     "Василина", "Василиса", "Венера", "Вера", "Вета", "Виктор", "Викторина", "Виктория", "Вилена", "Виталий",
     "Виталина", "Влад", "Влада", "Владана", "Владимир", "Владислав", "Владислава", "Владлен", "Влас", "Всеволод",
     "Вячеслав", "Гавриил", "Галина", "Геннадий", "Георгий", "Герасим", "Глафира", "Глеб", "Гордей", "Григорий",
     "Дамир", "Даниил", "Данил", "Данислав", "Дарья", "Демид", "Демьян", "Денис", "Джереми", "Дина", "Дмитрий",
     "Домника", "Евгений", "Евгения", "Евдоким", "Евдокия", "Евстахий", "Егор", "Екатерина", "Елена", "Елизавета",
     "Елисей", "Емельян", "Еремей", "Есения", "Ефим"]

key = "Владимир"

c_l = 0
c_r = len(contacts) - 1
c_c = (c_r - c_l) // 2 + c_l
# print(c_l, c_r, c_c) # границы левая, центр и правая соответственно
while key != contacts[c_c]:
    if key > contacts[c_c]:
        c_l = c_c
        c_c = (c_r - c_l) // 2 + c_l
        # print(c_l, c_r, c_c)
    elif key < contacts[c_c]:
        c_r = c_c
        c_c = (c_r - c_l) // 2 + c_l
        # print(c_l, c_r, c_c)

print("Контакт:", c_c, contacts[c_c])


# !!! Если 'key' в отсортированном массиве НЕ УНИКАЛЕН, то бинарный поиск сводится к поиску левой границы
# и правой границы !!!

# Алгоритм
# Поиск левой границы
def left_bound(A, key): # A - ОТСОРТИРОВАННЫЙ массив, key - искомое значение
    '''Поиск левой границы'''
    left = -1
    right = len(A)
    while right - left > 1:
        middle = (left + right)//2
        if A[middle] < key:
            left = middle
        else:
            right = middle
    return left


# Поиск правой границы
def right_bound(A, key): # A - ОТСОРТИРОВАННЫЙ массив, key - искомое значение
    '''Поиск правой границы'''
    left = -1
    right = len(A)
    while right - left > 1:
        middle = (left + right)//2
        if A[middle] <= key:
            left = middle
        else:
            right = middle
    return right